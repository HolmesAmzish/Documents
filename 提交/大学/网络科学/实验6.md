# 网络科学基础第五次上级报告

## 一、上机题目

完成BA网络的生成和GUI编程

## 二、上机目的

## 三、上机程序

### 生成BA无标度网络

```python
"""
BA_network.py
date: 2024-12-10
"""

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

plt.rcParams["font.sans-serif"] = ["SimHei"]
plt.rcParams["axes.unicode_minus"] = False

m0 = int(input("请输入未增长前的网络节点个数 m0: "))
m = int(input("请输入每次引入新节点时新生成的边数 m: "))
N = int(input("请输入增长后的网络节点总数 N: "))
se = int(input("请选择初始网络情况 1（孤立点）, 2（完全图）, 或 3（随机稀疏图）: "))

if m > m0:
    print("输入参数 m 不合法")
    exit()

# 构造初始网络
if se == 1:
    G = nx.empty_graph(m0)  # 孤立点
elif se == 2:
    G = nx.complete_graph(m0)  # 完全图
elif se == 3:
    G = nx.gnp_random_graph(m0, 0.1)  # 按概率0.1生成随机稀疏图
else:
    print("无效选择")
    exit()

# BA网络生成
new_node = m0
while new_node < N:
    # 获取现有节点的度
    degrees = np.array([G.degree(n) for n in G.nodes()])
    degree_sum = np.sum(degrees)

    # 计算连接概率
    probabilities = (degrees + 1) / (degree_sum + len(degrees))  # 防止度为零
    chosen_nodes = np.random.choice(
        G.nodes(), size=m, replace=False, p=probabilities
    )  # 根据概率选择节点

    # 添加新节点并连接
    G.add_node(new_node)
    G.add_edges_from((new_node, target) for target in chosen_nodes)

    new_node += 1

# 绘图
pos = nx.spring_layout(G)  # 使用弹簧布局绘图
plt.figure(figsize=(10, 8))
nx.draw_networkx_nodes(G, pos, node_color="r", node_size=50)
nx.draw_networkx_edges(G, pos, alpha=0.5)
plt.title("BA无标度网络")
plt.show()

# 计算节点度
degrees = dict(G.degree())  # 返回节点及其对应的度

# 绘制柱状图
plt.figure(figsize=(10, 6))
plt.bar(degrees.keys(), degrees.values(), color="blue", alpha=0.7, edgecolor="black")
plt.title("节点与度的柱状图", fontsize=14)
plt.xlabel("节点编号", fontsize=12)
plt.ylabel("度 (k)", fontsize=12)
plt.grid(axis="y", linestyle="--", alpha=0.6)
plt.show()

# 计算并绘制度分布
degrees = [d for _, d in G.degree()]
plt.figure(figsize=(8, 6))
plt.hist(degrees, bins=range(1, max(degrees) + 1), density=True, color="r", alpha=0.7)
plt.title("度分布")
plt.xlabel("节点度 (k)")
plt.ylabel("频率 (p)")
#plt.grid(True)
plt.show()

# 打印网络平均度
average_degree = 2 * G.number_of_edges() / G.number_of_nodes()
print(f"网络平均度: {average_degree:.2f}")
```

![](../../../img/62.png)

![](../../../img/63.png)

![](../../../img/64.png)

### GUI程序

```python
import tkinter as tk
from tkinter import ttk
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

class NetworkGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("网络模型与PageRank计算")
        self.root.geometry("800x600")

        self.create_widgets()

    def create_widgets(self):
        # Panel
        frame_controls = tk.Frame(self.root)
        frame_controls.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)

        tk.Label(frame_controls, text="选择网络类型:").pack(pady=5)
        self.network_type = ttk.Combobox(frame_controls, values=["随机网络", "小世界网络"])
        self.network_type.pack(pady=5)
        self.network_type.current(0)

        tk.Label(frame_controls, text="参数:").pack(pady=5)
        tk.Label(frame_controls, text="节点数 (N):").pack()
        self.entry_N = tk.Entry(frame_controls)
        self.entry_N.pack()

        tk.Label(frame_controls, text="概率/重连率 (p):").pack()
        self.entry_p = tk.Entry(frame_controls)
        self.entry_p.pack()

        tk.Label(frame_controls, text="随机跳转概率 (alpha):").pack()
        self.entry_alpha = tk.Entry(frame_controls)
        self.entry_alpha.pack()

        tk.Button(frame_controls, text="生成网络", command=self.generate_network).pack(pady=10)

        self.frame_canvas = tk.Frame(self.root)
        self.frame_canvas.pack(side=tk.RIGHT, expand=True, fill=tk.BOTH)

    def generate_network(self):
        try:
            N = int(self.entry_N.get())
            p = float(self.entry_p.get())
            alpha = float(self.entry_alpha.get())
        except ValueError:
            self.show_error("请正确输入数值参数！")
            return

        # generate network
        net_type = self.network_type.get()
        if net_type == "随机网络":
            self.graph = nx.erdos_renyi_graph(N, p)
        elif net_type == "小世界网络":
            self.graph = nx.watts_strogatz_graph(N, k=int(p * N), p=0.1)
        else:
            self.show_error("请选择正确的网络类型！")
            return

        self.plot_network()

        self.calculate_pagerank(alpha)

    def calculate_pagerank(self, alpha):
        if not hasattr(self, "graph"):
            self.show_error("请先生成网络！")
            return

        # PageRank
        pr = nx.pagerank(self.graph, alpha=alpha)
        pr_values = "\n".join([f"节点 {node}: {value:.4f}" for node, value in pr.items()])


        self.show_message("PageRank 值", pr_values)

    def plot_network(self):
        for widget in self.frame_canvas.winfo_children():
            widget.destroy()

        fig, ax = plt.subplots(figsize=(6, 5))
        pos = nx.spring_layout(self.graph)
        nx.draw(self.graph, pos, ax=ax, with_labels=True, node_color="skyblue", edge_color="gray", node_size=500, font_size=10)

        # Matplotlib figure
        canvas = FigureCanvasTkAgg(fig, master=self.frame_canvas)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def show_error(self, message):
        tk.messagebox.showerror("错误", message)

    def show_message(self, title, message):
        tk.messagebox.showinfo(title, message)

if __name__ == "__main__":
    root = tk.Tk()
    app = NetworkGUI(root)
    root.mainloop()
```

![image-20241210233235442](C:\Users\Holme\AppData\Roaming\Typora\typora-user-images\image-20241210233235442.png)

![image-20241210233255478](C:\Users\Holme\AppData\Roaming\Typora\typora-user-images\image-20241210233255478.png)

## 四、上机感悟

